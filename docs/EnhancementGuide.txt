Bugs:
	i  )Writing address pointer latency - write pointer gets updated for 2-3 cycles and stores last value in all these locations.
	ii )Reading address pointer latency - read pointer reads 2-3 cycles extra after raching writing address pointer due to synchronization delay.
	iii)Remove unnecessary flags.
	iv )Use GTK Wave.

Enhancements:
	i  )Catch all Latches caused due to uninitiated drivers and assign to it values for unutilised cycles.
	ii )Implement look ahead comparision logics to reduce Clk Cycles.
	iii)Improve readability of code - rename variables, proper indentation, comment important data and functions.
	iv )Optimise for configurable FIFO depth and width.
	
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
I want to synthesise my design now since its almost working, if it can get me results for the time being i ll move beyond this project and work on another one but if it doesnt, i ll leave it for later anyways

I designed the entirety of the code and model using modelsim and vscode, the file structure is also different from what modelsim creates, i want to implement and synthesize this design in vivado but there are a few challenges i am facing and i need your guidance with

1.how do i connect the vivado with these files i have created 
2.where do i save the vivado files, inside project/sync fifo folder alongside with src and tb folders, that doesnt sound so good since vivado creates many files and folders, and this will ruin the clean division. maybe i can make another folder inside sync fifo/vivado_imp_syn (or something) and create the vivado project inside that 
3.what files will i have to import inside vivado, will they copy past the files, or can i link them directly,
4.where do i save the reports and figures. (i feel like another folder inside sync fifo/results) should be fine, suggest a better alternative
5.i will have to define board and constrains files for implementation right ? i will need help with that, what to use


please make this detailed as possible
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
ChatGPT said:(1.2 RTL Blocks Configureable FIFO - SPI to FIFO transfer - 14th august,2025 - 8:30 a.m)

Awesome—great moment to checkpoint the work and get it into Vivado. Here’s a practical, step-by-step plan that answers your five questions and avoids making a mess of your repo.
0) Suggested repo layout

Keep your RTL clean and keep the bulky Vivado project out of src/. One tidy pattern:

sync-fifo/
│
├─ rtl/                 # Your synthesizable sources
│   ├─ FIFO.v
│   ├─ sync.v
│   ├─ binaryToGray.v
│   └─ grayToBinary.v
│
├─ sim/                 # Testbenches & sim-only files
│   └─ tb_fifo.v
│
├─ constr/              # XDC constraints (pins & clocks)
│   └─ top.xdc
│
├─ tools/
│   └─ vivado/          # The Vivado project lives here
│       └─ fifo_proj/   # Vivado .xpr and run/ cache dirs go here
│
├─ results/             # Place exported reports here
│   ├─ synth/
│   ├─ impl/
│   └─ cdc/
│
└─ scripts/             # Optional Tcl to create/build the project
    └─ create_build.tcl

This way your source tree remains portable and version-controllable, and Vivado’s heavy project cache is isolated.
1) How to connect Vivado to your existing files
GUI (quick way)

    Open Vivado → Create Project
    Location: …/sync-fifo/tools/vivado/fifo_proj
    Uncheck “Create project subdirectory” if you already made fifo_proj.

    Project Type: RTL Project → Uncheck “Copy sources into project”.
    (This keeps Vivado referencing your files in rtl/ and sim/ instead of copying them.)

    Add Sources:

        Add rtl/FIFO.v, rtl/sync.v, rtl/binaryToGray.v, rtl/grayToBinary.v.

        Set Top Module to your FIFO top (double-check port names; you had dataOu typo earlier—make it dataOut before synthesis).

    Add Simulation Sources (optional):

        Add sim/tb_fifo.v to the Simulation Sources set.

    Add Constraints:

        Add constr/top.xdc (you can leave it empty for synth-only, but you’ll need it for implementation).

    Part/Board:

        If you have a dev board supported by Vivado, select it (e.g., “Nexys A7” etc.).

        Otherwise pick the FPGA part (e.g., xc7a35t-1cpg236).

    Run Synthesis (no constraints required for synth).
    Run Implementation requires an XDC with pin assignments and clocks.

Tcl (repeatable & clean)

Create scripts/create_build.tcl:

# Create project
create_project fifo_proj ./tools/vivado/fifo_proj -force -part xc7a35ticsg324-1L

# Do not copy sources; use relative paths
set_property source_mgmt_mode None [current_project]

# Add RTL
add_files -fileset sources_1 [glob ../rtl/*.v]

# Add TB
add_files -fileset sim_1 ../sim/tb_fifo.v

# Add constraints
add_files -fileset constrs_1 ../constr/top.xdc

# Set top
set_property top FIFO [get_filesets sources_1]

# Synthesis
launch_runs synth_1
wait_on_run synth_1

# Implementation
launch_runs impl_1 -to_step write_bitstream
wait_on_run impl_1

# Export reports
file mkdir ../results/synth
file mkdir ../results/impl
report_timing_summary -file ../results/impl/timing_summary.rpt -return_string
report_utilization    -file ../results/impl/utilization.rpt
report_power          -file ../results/impl/power.rpt

# CDC (optional; basic checker)
file mkdir ../results/cdc
report_cdc -details -file ../results/cdc/cdc.rpt

Run in Vivado Tcl console: source ./scripts/create_build.tcl
2) Where to save the Vivado files

Your idea is spot on: put the project under something like
sync-fifo/tools/vivado/fifo_proj.
Do not sprinkle it inside rtl/ or sim/. Vivado creates many cache/run folders—keep them quarantined.
3) What files to import & whether they’re copied or linked

    Design sources (synthesizable):
    rtl/FIFO.v, rtl/sync.v, rtl/binaryToGray.v, rtl/grayToBinary.v

    Simulation sources:
    sim/tb_fifo.v (and any sim-only packages)

    Constraints:
    constr/top.xdc

If you uncheck “Copy sources into project”, Vivado links to your files. That’s best for active development. If you leave it checked, Vivado copies files into the project (they can go stale vs your repo).
4) Where to save reports & figures

Let Vivado run, then export reports to your results/ tree via:

    GUI: Open a report → “Save As”

    Tcl (recommended): use report_* -file ../results/... as shown above.

Suggested buckets:

results/
  synth/
     utilization.rpt
     timing_summary.rpt
  impl/
     utilization.rpt
     timing_summary.rpt
     power.rpt
  cdc/
     cdc.rpt

5) Boards & constraints (XDC): what you need

You can synthesize without constraints.
For implementation/bitstream, you must:

    Assign pins (PACKAGE_PIN + IOSTANDARD) for each top I/O.

    Define clocks and their periods.

    Declare CDC timing exceptions so STA doesn’t try to time across async domains.

Minimal XDC template (edit pins to match your board)

## Clocks
create_clock -name ClkWrite -period 10.000 [get_ports ClkWrite] ;# 100 MHz
create_clock -name ClkRead  -period 12.500 [get_ports ClkRead ] ;# 80  MHz

## Declare clocks asynchronous to each other (CDC)
set_clock_groups -asynchronous \
  -group [get_clocks ClkWrite] \
  -group [get_clocks ClkRead]

## Reset (active high assumed)
set_property PACKAGE_PIN <PIN_RESET>   [get_ports reset]
set_property IOSTANDARD LVCMOS33       [get_ports reset]

## Control
set_property PACKAGE_PIN <PIN_CTRL>    [get_ports Control]
set_property IOSTANDARD LVCMOS33       [get_ports Control]

## Data in/out
# Replace <PIN_*> with real pins from your board’s schematic/XDC example.
foreach i {0 1 2 3 4 5 6 7} {
  set_property PACKAGE_PIN <PIN_DI$i>  [get_ports {dataIn[$i]}]
  set_property IOSTANDARD LVCMOS33     [get_ports {dataIn[$i]}]
  set_property PACKAGE_PIN <PIN_DO$i>  [get_ports {dataOut[$i]}]
  set_property IOSTANDARD LVCMOS33     [get_ports {dataOut[$i]}]
}

## Halt output
set_property PACKAGE_PIN <PIN_HALT>    [get_ports haltInput]
set_property IOSTANDARD LVCMOS33       [get_ports haltInput]

## Clock pins (use your board’s dedicated clock pins)
set_property PACKAGE_PIN <PIN_CLKW>    [get_ports ClkWrite]
set_property IOSTANDARD LVCMOS33       [get_ports ClkWrite]
set_property PACKAGE_PIN <PIN_CLKR>    [get_ports ClkRead]
set_property IOSTANDARD LVCMOS33       [get_ports ClkRead]

    If your board only exposes one external clock: that’s normal. For bring-up you can:

        Drive both ClkWrite and ClkRead from the same pin (they’ll be synchronous in hardware, but it still synthesizes/implements fine), or

        Use an MMCM/PLL to make a second clock (still same reference; not truly async, but okay for a demo).

CDC best practices in Xilinx (important)

Mark your synchronizer flip-flops so synthesis/impl treats them correctly:

In RTL, on the two registers of each sync chain:

(* ASYNC_REG = "TRUE", SHREG_EXTRACT = "NO" *) reg [3:0] sync_1;
(* ASYNC_REG = "TRUE", SHREG_EXTRACT = "NO" *) reg [3:0] sync_2;

    ASYNC_REG helps place sync flops together and model MTBF correctly.

    SHREG_EXTRACT="NO" prevents the tool from collapsing your synchronizer into an SRL.

And keep the timing exception:

set_clock_groups -asynchronous -group [get_clocks ClkWrite] -group [get_clocks ClkRead]

Quick sanity checks before synth

    Top port names match your testbench and constraints (dataOut, not dataOu).

    No multiply-driven regs, no latches.

    No blocking assignments (=) in clocked always @ (posedge …) blocks; use non-blocking (<=).

    Memory: reg [7:0] mem [0:7]; → will infer distributed RAM/LUTs. That’s fine.

What you’ll get out of the box

    Synthesis: Utilization report (LUTs/FFs), inferred RAM, max frequency estimates.

    Implementation: Timing closure vs your clock periods, power estimate, bitstream.

    CDC report: Basic crossings summary (will ignore crossings due to set_clock_groups but useful to confirm structure).

Bonus: minimal TB to run in Vivado (optional)

You can keep using ModelSim, but if you want to see waves in Vivado’s xsim, add sim/tb_fifo.v to Simulation Sources, set it as the Simulation top, and run Behavioral Simulation. That doesn’t affect synthesis/impl.
Short answers to your bullets

    Connect Vivado to your files: “Create Project” → add sources by reference (uncheck copy). Point to rtl/ and sim/.

    Where to save Vivado files: put the project under tools/vivado/fifo_proj/ (keep it out of src/).

    What to import: RTL, sim, and XDC. Prefer linking (don’t copy) during early dev.

    Where to save reports: export them to results/{synth,impl,cdc} via GUI or Tcl.

    Board & constraints: choose your board/part; create an XDC with pin assignments, create_clock for both clocks, and set_clock_groups -asynchronous. Mark synchronizer flops with ASYNC_REG & SHREG_EXTRACT="NO".

If you want, paste your exact top module ports and the board you’re targeting—I’ll draft a concrete top.xdc tailored to it so you can implement immediately.